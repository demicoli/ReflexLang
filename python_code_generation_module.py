import os
from ast_classes import *


class CodeGenerator:
    """Generates Python modules based on an AST representation of a ReflexLang service definition."""

    def __init__(self, ast, output_dir='GeneratedService'):
        """
        Initializes the CodeGenerator with an AST and output directory.

        Parameters:
            ast (ServiceDefinition): Parsed AST representing the ReflexLang service definition.
            output_dir (str): Directory to store the generated Python files.
        """
        self.ast = ast
        self.output_dir = output_dir
        self.indent_level = 0
        self.modules = {
            'main': [],
            'algorithms': [],
            'resources': [],
            'monitoring': [],
            'state_management': []
        }

    def generate(self):
        """Main function to generate all Python files based on the AST structure."""
        self.create_directory()
        self.generate_init()
        self.generate_abstract_algorithm()
        self.generate_algorithms()
        self.generate_resources()
        self.generate_monitoring()
        self.generate_state_management()
        self.generate_main()
        self.write_modules()

    def create_directory(self):
        """Creates the output directory if it doesnâ€™t exist."""
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

    def generate_init(self):
        """Creates an __init__.py file to mark the output directory as a package."""
        init_path = os.path.join(self.output_dir, '__init__.py')
        with open(init_path, 'w') as f:
            f.write("# This package was generated by ReflexLang CodeGenerator\n")

    def generate_abstract_algorithm(self):
        """Generates an abstract base class for algorithms with necessary methods."""
        code_lines = []
        code = f"""from abc import ABC, abstractmethod


class Algorithm(ABC):
    @abstractmethod
    def initialize(self):
        pass

    @abstractmethod
    def deinitialize(self):
        pass

    @abstractmethod
    def process(self, input_data):
        pass

    """
        code_lines.append(code)
        self.modules['abstract_algorithm'] = code_lines

    def generate_algorithms(self):
        """Generates code for both complex and reflex algorithms, using inline code or external references."""
        code_lines = []
        for algo in [self.ast.complex_algorithm, self.ast.reflex_algorithm]:
            if algo.body.code:
                code = f"# {algo.name} Algorithm Implementation\n" + algo.body.code
                code_lines.append(code)
            elif algo.body.include:
                # Include the code or import the module
                module_name = algo.body.module_name or algo.name
                # Import the external module
                code_lines.append(f"# {algo.name} Algorithm is included from external module '{module_name}'")
                code_lines.append(f"from .{algo.body.include.rstrip('.py')} import {module_name}\n")
                # Re-export the class under the expected name
                code_lines.append(f"{algo.name} = {module_name}\n")
            else:
                code_lines.append(f"# {algo.name} has no implementation")
        self.modules['algorithms'] = code_lines

    def generate_resources(self):
        """Generates the resource manager class and initializes resources based on their data types."""
        default_values = {
            'Float': '0.0',
            'Integer': '0',
            'String': "''",
            'Boolean': 'False',
            # Add other data types as needed
        }
        code_lines = ["# Resources Module", "class ResourceManager:", "    def __init__(self):"]
        for res in self.ast.resources:
            res_name = res.name.lower()
            code_lines.append(f"        # Resource: {res.name}")
            code_lines.append(f"        self.{res_name} = {default_values[res.data_type]}  # Type: {res.type}, DataType: {res.data_type}")

        code_lines.append("")

        for res in self.ast.resources:
            res_name = res.name.lower()
            code_lines.append(f"    # Resource: {res.name}")
            code_lines.append(f"    def set_{res_name}(self, value):")
            code_lines.append(f"        self.{res_name} = value")
            code_lines.append("")

        code_lines.append("    def update_resources(self):")
        code_lines.append("        # Implement resource data acquisition here")
        code_lines.append("        pass")
        self.modules['resources'] = code_lines

    def generate_monitoring(self):
        """Generates monitoring classes based on threshold or external monitoring configurations."""
        code_lines = ["# Monitoring Module"]
        for mb in self.ast.monitoring_blocks:
            if isinstance(mb.function, ThresholdMonitoring):
                code = self.generate_threshold_monitoring(self, mb)
                code_lines.append(code)
            elif isinstance(mb.function, ExternalMonitoring):
                code = self.generate_external_monitoring(self, mb)
                code_lines.append(code)
        self.modules['monitoring'] = code_lines

    @staticmethod
    def generate_threshold_monitoring(self, mb):
        activate = mb.function.activate_threshold
        deactivate = mb.function.deactivate_threshold
        code = f"""
class {mb.name}:
    def __init__(self, resource_manager):
        self.resource_manager = resource_manager
        self.activate_threshold = {activate}
        self.deactivate_threshold = {deactivate}
        self.active = False

    def check(self):
        # Replace 'resource_value' with actual resource value
        resource_value = self.resource_manager.{mb.inputs[0].lower()}
        if not self.active and resource_value > self.activate_threshold:
            self.active = True
            return True
        elif self.active and resource_value < self.deactivate_threshold:
            self.active = False
            return False
        return self.active
        """
        return code

    @staticmethod
    def generate_external_monitoring(self, mb):
        """
        Generates an external monitoring class.

        Parameters:
           mb (MonitoringBlock): Monitoring block with an external algorithm.

        Returns:
            str: Generated class code for external monitoring.
        """
        algorithm_name = mb.function.name
        algo_body = mb.function.algorithm_body
        parameters = mb.function.parameters

        code_lines = []

        # Handle the algorithm inclusion
        if algo_body.include:
            include_module = algo_body.include.rstrip('.py')
            module_alias = algo_body.module_name or algorithm_name
            # Import the external monitoring algorithm
            code_lines.append(f"from {include_module} import {module_alias}")
            # Re-export under the expected class name
            code_lines.append(f"{algorithm_name} = {module_alias}")
        else:
            # If code is provided directly
            code_lines.append(f"# {algorithm_name} Implementation")
            code_lines.append(algo_body.code)

        # Generate the monitoring class
        code_lines.append(f"""
    class {mb.name}:
        def __init__(self, resource_manager):
            self.resource_manager = resource_manager
            self.algorithm = {algorithm_name}({self.format_parameters(self, parameters)})

        def check(self):
            # Implement the external monitoring logic
            result = self.algorithm.process(self.resource_manager)
            return result
    """)
        return '\n'.join(code_lines)

    @staticmethod
    def format_parameters(self, parameters):
        if not parameters:
            return ''
        param_str = ', '.join(f"{k}={repr(v)}" for k, v in parameters.items())
        return param_str

    def generate_state_management(self):
        """Generates code for the state management strategy based on the specified strategy type."""
        code_lines = []
        strategy = self.ast.state_management.strategy
        if strategy == 'Shared_Data_Store':
            code_lines.append("# State Management Module: Shared Data Store")
            code_lines.append("class SharedDataStore:")
            code_lines.append("    def __init__(self):")
            for item in self.ast.state_management.data_items:
                code_lines.append(f"        self.{item.name} = None  # DataType: {item.data_type}")
        elif strategy == 'Checkpointing':
            code_lines.append("# State Management Module: Checkpointing")
            code_lines.append("import pickle")
            code_lines.append("class CheckpointingState:")
            code_lines.append("    def __init__(self):")
            for item in self.ast.state_management.data_items:
                code_lines.append(f"        self.{item.name} = None  # DataType: {item.data_type}")
            code_lines.append("")
            code_lines.append("    def save_state(self, filename='checkpoint.pkl'):")
            code_lines.append("        with open(filename, 'wb') as f:")
            code_lines.append("            pickle.dump(self, f)")
            code_lines.append("")
            code_lines.append("    @staticmethod")
            code_lines.append("    def load_state(filename='checkpoint.pkl'):")
            code_lines.append("        with open(filename, 'rb') as f:")
            code_lines.append("            return pickle.load(f)")
        else:  # Stateless
            code_lines.append("# State Management Module: Stateless (No state management needed)")
        self.modules['state_management'] = code_lines

    def generate_main(self):
        """Generates the main service module, which integrates algorithms, resources, and monitoring blocks."""
        code_lines = ["# Main Module",
                      "import threading",
                      "import time",
                      "from .algorithms import *",
                      "from .resources import ResourceManager",
                      "from .monitoring import *"]
        strategy = self.ast.state_management.strategy
        if strategy != 'Stateless':
            code_lines.append("from .state_management import *")
        code_lines.append("")
        code_lines.append("")
        code_lines.append("class Service:")

        # Init Function
        code_lines.append("    def __init__(self):")
        code_lines.append("        self.resource_manager = ResourceManager()")
        if strategy == 'Shared_Data_Store':
            code_lines.append("        self.state = SharedDataStore()")
        elif strategy == 'Checkpointing':
            code_lines.append("        self.state = CheckpointingState()")
        else:
            code_lines.append("        self.state = None  # Stateless")
        code_lines.append("        self.use_reflex = False")
        code_lines.append("        self.lock = threading.Lock()")
        code_lines.append("        self.active_algorithm = None")
        code_lines.append("        self.result_queue = []  # To store results when shadowing")
        code_lines.append("        self.init_algorithms()")
        code_lines.append("        self.init_monitoring()")
        code_lines.append("")

        # Init Algorithms
        shadowing_enabled = self.ast.reflex_algorithm.shadowing
        code_lines.append("    def init_algorithms(self):")
        # Instantiate both algorithms
        for algo in [self.ast.complex_algorithm, self.ast.reflex_algorithm]:
            algo_name = algo.name
            code_lines.append(f"        self.{algo_name.lower()} = {algo_name}(self.state)")
        # Initialize only the complex algorithm by default
        code_lines.append(f"        self.{self.ast.complex_algorithm.name.lower()}.initialize()")
        code_lines.append(f"        self.active_algorithm = self.{self.ast.complex_algorithm.name.lower()}")
        if shadowing_enabled:
            code_lines.append(f"        self.{self.ast.reflex_algorithm.name.lower()}.initialize()")
        code_lines.append("")

        # Monitoring Blocks
        code_lines.append("    def init_monitoring(self):")
        for mb in self.ast.monitoring_blocks:
            mb_name = mb.name
            code_lines.append(f"        self.{mb_name.lower()} = {mb_name}(self.resource_manager)")
            code_lines.append(f"        threading.Thread(target=self.monitor_{mb_name.lower()}, daemon=True).start()")
        code_lines.append("")

        # Implement the monitoring functions
        for mb in self.ast.monitoring_blocks:
            mb_name = mb.name.lower()
            code_lines.append(f"    def monitor_{mb_name}(self):")
            code_lines.append(f"        while True:")
            code_lines.append(f"            self.resource_manager.update_resources()")  # Update resource values
            code_lines.append(f"            if self.{mb_name}.check():")
            code_lines.append(f"                self.switch_to_reflex()")
            code_lines.append(f"            else:")
            code_lines.append(f"                self.switch_to_complex()")
            code_lines.append("            time.sleep(1)")
        code_lines.append("")
        shadowing_enabled = self.ast.reflex_algorithm.shadowing
        if shadowing_enabled:
            # Implement shadowing logic
            code_lines.append("    def process(self, input_data):")
            code_lines.append("        with self.lock:")
            code_lines.append("            return self.active_algorithm.process(input_data)")
            """
            code_lines.append("    def process(self, input_data):")
            code_lines.append("        # Start reflex algorithm in a separate thread")
            code_lines.append("        reflex_thread = threading.Thread(target=self.run_reflex, args=(input_data,))")
            code_lines.append("        reflex_thread.start()")
            code_lines.append("        # Run complex algorithm")
            code_lines.append("        complex_result = self.complexdetection.process(input_data)")
            code_lines.append("        # Wait for reflex result or return complex result")
            code_lines.append("        if self.result_queue:")
            code_lines.append("            reflex_result = self.result_queue.pop(0)")
            code_lines.append("            return reflex_result")
            code_lines.append("        else:")
            code_lines.append("            reflex_thread.join()")
            code_lines.append("            return complex_result")
            code_lines.append("")
            code_lines.append("    def run_reflex(self, input_data):")
            code_lines.append("        result = self.simpledetection.process(input_data)")
            code_lines.append("        self.result_queue.append(result)")
            """
        else:
            # Original process method without shadowing
            code_lines.append("    def process(self, input_data):")
            code_lines.append("        with self.lock:")
            code_lines.append("            return self.active_algorithm.process(input_data)")
        code_lines.append("")
        # Switch to Reflex
        code_lines.append("    def switch_to_reflex(self):")
        code_lines.append("        with self.lock:")
        code_lines.append("            if not self.use_reflex:")
        code_lines.append("                print('Switching to Reflex Algorithm')")
        code_lines.append("                # Perform state exchange")
        if not shadowing_enabled:
            # De-initialize current algorithm
            code_lines.append("                self.active_algorithm.deinitialize()")
            code_lines.append(f"                self.active_algorithm = self.{self.ast.reflex_algorithm.name.lower()}")
            code_lines.append("                self.active_algorithm.initialize()")
        else:
            # Shadowing is enabled, no need to de-init/init algorithms
            code_lines.append(f"                self.active_algorithm = self.{self.ast.reflex_algorithm.name.lower()}")
        code_lines.append("                self.use_reflex = True")
        code_lines.append("")

        # Switch to Complex
        code_lines.append("    def switch_to_complex(self):")
        code_lines.append("        with self.lock:")
        code_lines.append("            if self.use_reflex:")
        code_lines.append("                print('Switching to Complex Algorithm')")
        code_lines.append("                # Perform state exchange")
        if not shadowing_enabled:
            # De-initialize current algorithm
            code_lines.append("                self.active_algorithm.deinitialize()")
            code_lines.append(f"                self.active_algorithm = self.{self.ast.complex_algorithm.name.lower()}")
            code_lines.append("                self.active_algorithm.initialize()")
        else:
            # Shadowing is enabled, no need to de-init/init algorithms
            code_lines.append(f"                self.active_algorithm = self.{self.ast.complex_algorithm.name.lower()}")
        code_lines.append("                self.use_reflex = False")
        code_lines.append("")

        # Service Instance
        code_lines.append("# Create an instance of the service")
        code_lines.append("service_instance = Service()")
        code_lines.append("")
        code_lines.append("")

        # Process as interface function
        code_lines.append("# Interface function")
        code_lines.append("def process(input_data, resource_values=None):")
        code_lines.append("    if resource_values:")
        code_lines.append("        # Set resource values")
        code_lines.append("        for key, value in resource_values.items():")
        code_lines.append("            setattr(service_instance.resource_manager, key, value)")
        code_lines.append("    return service_instance.process(input_data)")
        code_lines.append("")
        self.modules['main'] = code_lines

    def write_modules(self):
        """Writes the generated code for each module to the respective files in the output directory."""
        for module_name, code_lines in self.modules.items():
            file_name = f"{module_name}.py"
            file_path = os.path.join(self.output_dir, file_name)
            with open(file_path, 'w') as f:
                f.write('\n'.join(code_lines))
